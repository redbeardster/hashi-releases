Знакомство с Erlang 
Выполнение обновление OTP-приложений в реальном времени.
Автор: Митчелл Хашимото, дата публикации: 24 сентября, 2008


Это - седьмая и заключительная статья цикла введения в Erlang/OTP. Если Вы еще не сделали этого, я рекомендую прочитать первую статью (которая не только является фундаментом разрабатываемого в рамках данного цикла приложения, но и дает некоторые знания основ Erlang/OTP), перед тем как приступить к чтению данной. 

Предыстория: Erlybank уже держится на плаву в течение нескольких месяцев и, по просьбе заказчика, банк хочет внедрить несколько дполнительных свойств. Во-первых, они хотят, чтобы мы реализовали кредитный аккаунт. Он похож на обычный с той лишь разницей, что можно "уходить в минус", то есть, разница берется в долг у банка. Также они хотят, чтобы мы поменяли логику работы банкомата так, чтобы можно было им пользоваться для оплаты услуг кредитного аккаунта. И, как  наиболее важное требование, они просят нас реализовать это с минимальным возможным временем простоя. 

Итого, мы создадим кредитный сервер для простого добавления кредитного аккаунта и в дальнейшем меняя логику работы банкомата. К счастью для нас, сделав эти изменения единожды, мы сможем с легкостью обновлять систему в режиме реального времени так, чтобы ErlyBank не заметил длительного, если вообще заметит, перерыва в работе.


*Кредитный аккаунт*

Перво-наперво, требуется реализация кредитного аккаунта. Erlybank хочет получить совершенно другую логику работы, так что мне пришлось создать модуль eb_credit.erl как gen_server  для реализации нужной логики обработки. Если Вы чувствуетее в себе достаточно сил, я рекомендую попробовать реализовать этот модуль самостоятельно. Единственные необходимые функции модуля: создание аккаунта, съем денег и депозиты (оплата счетов), ибо это все, что мы будем использовать в данной статье. Для своего удовольствия можно реализовать такие функции как удаление аккаунтов, отправку событий event-менеджеру и прочие. 

Так как данная статья в большей степени описывает обновление системы в реальном времени, чем gen_server, то я  уже создал файл eb_credit.erl,  который вы можнте просмотреть. 

*Изменения в банкомате*

ErlyBank также хочет внести изменения в банкомат, чтобы при входе в систему пользователя с кредитным аккаунтом он могу бы только погасить задолженность или увеличить свой баланс. Для этого я изменю схему авторизации в eb_server для проверки кредитного сервера. eb_server:authorize() будет возвращать "ok" и сообщать, к какому типу аккаунта относится аккаунт пользователя. Это немало кода, так что я ознакомлю вас с тем, что сделал. Существует множество очевидных проблем в этой задаче, например, из-за того, что  кредитный и дебетовый аккаунты могут иметь одно и тоже имя и PIN-код, в результате чего функционал авторизации может вернуть неверные данные. Причина, по которй я делаю эти "ошибки" намеренно - продемонстрировать различные методы обновления релизов. После прочтения данной главый вы вполне можете попробовать исправить сервер, чтобы сделать его чуть более реалистичным. 

authorize(Name, PIN) ->
  case gen_server:call(?SERVER, {authorize, Name, PIN}) of
    ok ->
      {ok, debit};
    {error, _Reason} ->
      case eb_credit:authorize(Name, PIN) of
        ok ->
          {ok, credit};
        {error, Reason} ->
          {error, Reason}
      end
  end.

  Данная функция смотрится более-менее незатейливо. Она проверяет, существует ли дебитовый аккаунт с такими же именем и PIN-кодом, и если существует, то возвращает {ok, debit}, иначе проверяет наличие кредитного аккаунта. 

  После изменения метода авторизации для сервера, нам требуется изменить метод авторизации так, чтобы отличать кредитный аккаунт. Вспомните, что ErlyBank желает иметь кредитные учетные записи только для пополнения баланса, но не для вывода наличных. С помощью сопоставления с образцом в Erlang это выполняется просто: 


  unauthorized({authorize, Name, Pin}, _From, State) ->
  case eb_server:authorize(Name, Pin) of
    {ok, debit} ->
      {reply, ok, authorized, Name};
    {ok, credit} ->
      {reply, ok, authorized, {credit, Name}};
    {error, Reason} ->
      {reply, {error, Reason}, unauthorized, State}
  end;

 Сперва изменим запрос на авторизацию для банкомата. Это довольно просто, так как просто проверить, является ли ответ "debit" или "credit". В первом случае мы не делаем никаких изменений, используется тот же код, что и для предыдущей версии eb_atm. В противном случае, если это кредитный аккаунт, внутреннее состояние банкомата устанавливается в {credit, Name}.

Для того, чтобы дать возиожность снимать наличные только дебетовому аккаунту, мы осуществляем проверку, что состояние сервера - список ("строка" в Erlang) в функции deposit, как видно далее: 

authorized({withdraw, Amount}, _From, State) when is_list(State) ->

Теперь, когда с кредитного аккаунта пытаются снять деньги, выдается неверное сообщение об ошибке, так как происходит "спуск" вниз к функции, "отлавливающей" аргумент, которому ничего не было сопоставлено ранее. Вот как это выглядит для метода авторизации: 

authorized({deposit, Amount}, {credit, Account}=State) ->
  eb_credit:deposit(Account, Amount),
  {next_state, thank_you, State, 5000};
authorized({deposit, Amount}, State) ->
  eb_server:deposit(State, Amount),
  {next_state, thank_you, State, 5000};
authorized(_Event, State) ->
  {next_state, authorized, State}.

Первая функция "ловит" кредитные аккаунты и осуществляет депозит по ним, вторая - дебетовые аканты, третья обрабатывает ошибки. Вот и все изменения в банкомате. 


*Инструкции для управления релизами*

Наконец, мы добрались до интересной части. В Erlang/OTP обновление задается набором инструкций по прееходу от ндной версии к другой. Каждая инструкция - кортеж, являющийся частью списка, где каждая инструкция высполняется в порядке очередности в данном списке. Существуют высокоуровневые и низкоуровневые инструкции, краткий обзор их приведен ниже: 

	{load_module, Module} - простая загрузка новой версии модуля Module. Если внутреннее состояние не изменяется и  требуется только добавить новый код или изменить существующий, этой команды достаточно. В качестве примера можно расммотреть математическую библлиотеку, где происходит исправление ошибки или добавление новой функциональности. 

	{update, Module, {advanced, Extra}} - при изменении внутреннего состояния модуля простая перезагрузка кода сработает, так как это вызовет искаженное изменение запущенных процессов. Команда update заставляет сработать функцию обратного вызова code_change  и передает ей в качестве аргументов текущее состояние и параметр Extra. Выполняя этот вызов, модуль обновляется до последней версии. code_change() необходимо использовать для приведения состояния модуля к актуальному.

	{add_module/delete_module, Module} - если добавляется новый модуль, add_module() просто загружает его в соответствующее адресное пространство. При необходимости удалениz модуля функция delete_module() удаляет его. Все запущенные модулем процессы завершаются принудительно. 

	{apply, {M, F, A}} - низкоуровневая инструкция, осуществляющая вызов функции из заданного модуля с заданными аргументами. 

	Конечно, в действительности список инструкций куда больше, но вышеупомянутых мне хватало в большинстве случаев. 


*Инструкции для обновления ErlyBank*

Итак, вспомним о внесенных в код изменениях, какие инструменты нам потребуются и каков будет порядок их вызова? Наши изменения в коде: 

	Новый модуль - eb_credit.erl
    Изменение внутреннего состояния eb_server
    Изменение кода eb_atm
    Добавление eb_credit в дерево супервизора

Для развлечения порпобуйте самостоятельно подобрать инструкции для обновления ErlyBank. Далее я привожу инстуркции и порядок их следования с объяснениями: 


	{add_module, eb_credit} - Добавление жданного модуля не приведет к перегрузу системы, но так как остальные инстуркции зависят от него, я загружаю его первым.

    {update, eb_sup, supervisor} - далее обновляем супервизор так, чтобы запустить eb_credit. 

    {load_module, eb_server} - eb_server зависит от eb_credit, теперь самое время запустить и его!

    {update, eb_atm, {advanced, []}} - И, наконец, мы обновлеям код банкомата с параметром advanced, так как произошло изменение его внутреннего состояния. Делаем это в последнюю очередь, так как он зависит от  eb_server.

Эти инструкции должны быть записаны в файл апгреда приложения ("appup"-файл), имеющий такой формат: 

	{NewVsn,
	  [{OldVsn1, [Instructions]}],
	  [{OldVsn1, [Instructions]}]
	}.

Перввый параметр - номер новой версии, за котрым следует список кортежей. Каждый из них представляет путь обновления для своей версии со списком инструкций обновления с каждой из них. Следующий список содержит инструкции отката от данной версии. С учетом этого, файл обновления приложения ErlyBank выглядит так: 

	{"2.0",
	 [{"1.0", [{add_module, eb_credit},
	           {update, eb_sup, supervisor},
	           {load_module, eb_server},
	           {update, eb_atm, {advanced, []}},
	            ]}],
	  [{"1.0", [{update, eb_atm, {advanced, []}},
	           {load_module, eb_server},
	           {update, eb_sup, supervisor},
	           {delete_module, eb_credit}]}
	 ]
	}.


Как вы видите, инструкуции совершенно идентичны, разница лишь в обратном порядке при "откате" назад. Требуется только изменение от версии 1, так как эта версия единственная.   Файл должен быть сохранен как erlybank.appup и помещен в каталог ebin наряду с .app-файлом.  

Теперь необходимо обновить .rel-файл, изменив номер версии на 2 и переименовав его в b_rel-2.rel.


*Файл обновления релиза*

Необходимо также иметь данный файл, называемый иначе relup-файлом, для полного описания апгрейда приложения. К счастью для нас, его не треуется создавать вручную. Запустите оболочку в корневом каталоге ErlyBank  и добавьте "ebin/" наряду с путем к предыдущей версии ebin/ и .rel-файла, вы уже знаете, как это сделать.  Если забыли, сделайте вот так: 

	erl -pz ebin/ -pz ../old/ -pz ../old/ebin

Затем выполните следующую команду в оболочке: 

	systools:make_relup("eb_rel-2", ["eb_rel-1"], ["eb_rel-1"]).

Если все файлы были найдены, то ответом будет атом "ok". Если нет, то вы получите сообщение об ошибке и осписанием того, что произошло. результатом вызова данной команды будет relup-файл в рабочем каталоге. 


*Сборка пакета и установка ErlyBank-2.0*


Предполагается, что вы уже знаете, как собрать пакет для релиза, действия те же, что и в предыдущей статье. Если вы не уверены, вернитесь к ней. Установка осуществляется аналогично, просто распакуйте сжатый файл в каталог релизов. 

После этого, учитывая запущенный в настоящее время релиз, мы установим следующий. Установка послечет за собой запуск relup-файла. Чтобы сделать это, наберите в приглашении оболочки: 

	release_handler:install_release("2").

Несмотря на то, что теперь установлен пакет новой версии, версия текущего пакета по-прежнему "1". Для задания нового кода по умолчанию, выполните следующую команду: 

	release_handler:make_permanent("2").
 
 Вот и все! ErlyBank незаметно обновлен! 

 *Финальные заметки*

 	В этой статье я познакомил вас с обновлением приложений в реальном времени, написанных на Erlang/OTP. Были описаны наиболее часто используемые функции и процесс обновления версии релиза. Тем не менее, были добавлены некоторые инструкции сверх необходимого. Так, напирмер, несмотря на изменение состояния, eb_atm не было надобности в усложненном обновлении кода, так как мы не меняли структуру информации о состоянии, только лишь добавили новую. Если вы хотите узнать больше, рекомендую вам Appup Cookbook. 